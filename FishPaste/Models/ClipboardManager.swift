//
//  ClipboardManager.swift
//  FishPaste
//
//  Created by 俞云烽 on 2025/04/02.
//

import SwiftUI
import Combine
import SwiftData
import AppKit
import UniformTypeIdentifiers  // 添加 UTType 支持
import ServiceManagement  // 添加 ServiceManagement 框架支持
import Foundation.NSDistributedNotificationCenter

// 剪贴板管理器：负责监控系统剪贴板变化和管理历史记录
class ClipboardManager: ObservableObject {
    // 发布最新的剪贴板内容
    @Published var currentClipboardContent: ClipboardContent?
    // 剪贴板历史记录
    @Published var clipboardHistory: [ClipboardContent] = []
    // 选择的项目
    @Published var selectedItems: Set<UUID> = []
    // 监控状态
    @Published var isMonitoring: Bool = true
    // 监控间隔（秒）
    @AppStorage("monitoringInterval") var monitoringInterval: Double = 0.5
    // 音效设置
    @AppStorage("enableSoundEffects") var enableSoundEffects: Bool = true
    // 排除的应用列表
    private var excludedAppBundleIds: [String] = []
    
    // 其他规则设置
    private var ignoreIosData: Bool = UserDefaults.standard.bool(forKey: "ignoreIosData")
    private var ignorePrivateData: Bool = UserDefaults.standard.bool(forKey: "ignorePrivateData")
    private var ignoreAutoGeneratedData: Bool = UserDefaults.standard.bool(forKey: "ignoreAutoGeneratedData")
    private var convertLargeExcelToText: Bool = UserDefaults.standard.bool(forKey: "convertLargeExcelToText")
    private var ignoreSizeLimit: Double = Double(UserDefaults.standard.string(forKey: "ignoreSizeLimit") ?? "0.0") ?? 0.0
    
    // 用于检测通用剪贴板的变量
    private var recentChangeTimestamps: [Date] = []
    private var lastActiveAppBundle: String? = nil
    private var lastPasteboardText: String? = nil
    private var continueFromUniversalClipboard: Bool = false
    
    // 手动iOS检测的变量
    private var forceIOSDetectionUntil: Date? = nil
    
    // 音效对象
    private var clipboardChangedSound: NSSound?
    private var manualCopySound: NSSound?
    
    // 标记是否为内部复制操作，避免重复播放音效
    private var isInternalCopyOperation = false
    // 内部复制操作的时间戳，用于避免冲突
    private var lastInternalCopyTime: Date?
    
    // 用于监听Handoff和系统事件的变量
    private var handoffActivityObserver: Any?
    private var handoffDetectedTime: Date?
    private var lastHandoffBundleID: String?
    
    // 用于Handoff传递的UserActivity
    private var clipboardUserActivity: NSUserActivity?
    private var isHandoffSessionActive: Bool = false
    
    // SwiftData模型上下文
    private var modelContext: ModelContext?
    
    // 定时器用于定期检查剪贴板
    private var timer: Timer?
    // 当前剪贴板数据的校验和，用于检测变化
    private var lastChangeCount: Int = 0
    
    // 上次处理剪贴板的时间
    private var lastProcessTime: Date = Date()
    
    // 上次处理的内容ID
    private var lastProcessedContentID: UUID?
    
    // 最大历史记录大小
    private let maxHistorySize: Int = 500
    
    // 自定义的Handoff相关通知名称
    private let handoffReceivedNotification = Notification.Name("com.yuyunfeng.FishPaste.HandoffReceived")
    private let userActivityWillContinueNotification = Notification.Name("com.yuyunfeng.FishPaste.UserActivityWillContinue")
    private let userActivityDidUpdateNotification = Notification.Name("com.yuyunfeng.FishPaste.UserActivityDidUpdate")
    
    // 图像处理配置
    private var imageProcessingConfig = ImageProcessingConfig()
    // HEX颜色识别开关
    private var hexColorRecognitionEnabled: Bool = UserDefaults.standard.bool(forKey: "enableHEXColorRecognition")
    
    init() {
        // 从UserDefaults加载保存的监控间隔设置
        if let savedInterval = UserDefaults.standard.object(forKey: "monitoringInterval") as? Double {
            self.monitoringInterval = savedInterval
            print("从UserDefaults加载监控间隔设置: \(savedInterval)秒")
        }
        
        // 加载排除应用列表
        loadExcludedApps()
        
        // 加载音效
        loadSoundEffects()
        
        // 启动剪贴板监控
        startMonitoring()
        
        // 添加应用切换通知观察者
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(applicationDidChange),
            name: NSWorkspace.didActivateApplicationNotification,
            object: nil
        )
        
        // 启动Handoff事件检测
        setupHandoffDetection()
        
        // 创建并激活用于剪贴板的UserActivity
        setupClipboardUserActivity()
        
        // 加载测试数据（当真实数据库连接后可以移除）
        loadDemoData()
    }
    
    deinit {
        // 移除通知观察者
        NotificationCenter.default.removeObserver(self)
        
        // 移除Handoff观察者
        if let observer = handoffActivityObserver {
            NSWorkspace.shared.notificationCenter.removeObserver(observer)
        }
        
        // 失效UserActivity
        clipboardUserActivity?.invalidate()
    }
    
    // 设置用于剪贴板的UserActivity
    private func setupClipboardUserActivity() {
        // 创建用于表示剪贴板内容的UserActivity
        clipboardUserActivity = NSUserActivity(activityType: "com.yuyunfeng.FishPaste.clipboard")
        clipboardUserActivity?.title = "Universal Clipboard"
        clipboardUserActivity?.isEligibleForHandoff = true
        
        // 添加应用标识信息
        clipboardUserActivity?.addUserInfoEntries(from: [
            "appName": "FishPaste",
            "appBundleIdentifier": Bundle.main.bundleIdentifier ?? "com.yuyunfeng.FishPaste"
        ])
        
        // 设置为当前Activity
        clipboardUserActivity?.becomeCurrent()
        
        print("已设置并激活用于剪贴板的UserActivity")
        
        // 添加用于接收Handoff的观察者
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(didReceiveHandoffUserActivity(_:)),
            name: NSNotification.Name("NSUserActivityHandoffReceived"),
            object: nil
        )
    }
    
    // 接收Handoff的UserActivity
    @objc private func didReceiveHandoffUserActivity(_ notification: Notification) {
        print("接收到Handoff UserActivity通知")
        if let activity = notification.object as? NSUserActivity {
            print("活动类型: \(activity.activityType)")
            
            // 检查是否是通用剪贴板相关活动
            if activity.activityType.contains("clipboard") || 
               activity.activityType.contains("Clipboard") || 
               activity.activityType.contains("pasteboard") ||
               activity.activityType.contains("Pasteboard") {
                
                print("检测到通用剪贴板相关活动")
                isHandoffSessionActive = true
                handoffDetectedTime = Date()
                
                // 启用iOS检测模式
                enableForceIOSDetection(forSeconds: 5.0)
            }
        }
    }
    
    // 处理应用切换事件
    @objc private func applicationDidChange(_ notification: Notification) {
        if let app = notification.userInfo?[NSWorkspace.applicationUserInfoKey] as? NSRunningApplication {
            let currentBundle = app.bundleIdentifier
            print("应用切换: \(self.lastActiveAppBundle ?? "无") -> \(currentBundle ?? "无")")
            
            // 检查是否从其他应用切换到当前应用 - 这是通用剪贴板到达的可能情景
            if lastActiveAppBundle != currentBundle {
                // 记录应用切换时间
                recentChangeTimestamps.append(Date())
                // 只保留最近10次切换记录
                if recentChangeTimestamps.count > 10 {
                    recentChangeTimestamps.removeFirst()
                }
                
                // 保存当前活跃应用
                lastActiveAppBundle = currentBundle
                
                // 将可能是通用剪贴板的标志设为true
                continueFromUniversalClipboard = true
                
                // 记录当前剪贴板文本以便下次比较
                lastPasteboardText = NSPasteboard.general.string(forType: .string)
            }
        }
    }
    
    // 加载音效文件
    private func loadSoundEffects() {
        // 使用系统内置超短音效 - "Morse"作为剪贴板变化的提示音
        clipboardChangedSound = NSSound(named: "Morse")
        clipboardChangedSound?.volume = 0.3 // 降低音量以免干扰
        
        // 使用系统内置超短音效 - "Ping"作为手动复制的提示音
        manualCopySound = NSSound(named: "Ping") 
        manualCopySound?.volume = 0.4
        
        print("音效加载完成: 使用超短系统音效")
    }
    
    // 播放剪贴板变化音效
    private func playClipboardChangedSound() {
        // 如果这是一个内部复制操作或者在内部复制后的短时间内，不播放自动检测音效
        if isInternalCopyOperation || Date().timeIntervalSince(lastInternalCopyTime ?? Date()) < 1.0 {
            print("检测到内部复制操作，跳过自动检测音效")
            return
        }
        
        guard enableSoundEffects, let sound = clipboardChangedSound else { return }
        sound.stop() // 确保停止之前的播放
        sound.play()
    }
    
    // 播放手动复制音效
    private func playManualCopySound() {
        guard enableSoundEffects, let sound = manualCopySound else { return }
        sound.stop() // 确保停止之前的播放
        sound.play()
    }
    
    // 设置音效开关
    func setEnableSoundEffects(_ enable: Bool) {
        enableSoundEffects = enable
        UserDefaults.standard.set(enable, forKey: "enableSoundEffects")
        print("音效设置已更改: \(enable ? "启用" : "禁用")")
    }
    
    // 设置模型上下文
    func setModelContext(_ context: ModelContext) {
        print("设置ModelContext: \(context)")
        self.modelContext = context
        
        // 等待主线程队列执行完毕后再加载数据，确保UI初始化完成
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            // 在设置上下文后尝试加载保存的数据
            self.loadSavedClipboardItems()
        }
    }
    
    // 从数据库加载保存的剪贴板项目
    private func loadSavedClipboardItems() {
        guard let modelContext = modelContext else {
            print("警告: 无法加载保存的剪贴板项目，模型上下文未初始化")
            return
        }
        
        do {
            let descriptor = FetchDescriptor<ClipboardItem>(
                sortBy: [SortDescriptor(\.timestamp, order: .reverse)]
            )
            let savedItems = try modelContext.fetch(descriptor)
            
            if !savedItems.isEmpty {
                print("从数据库加载了 \(savedItems.count) 个剪贴板项目")
                
                // 清除演示数据并加载实际保存的数据
                clipboardHistory.removeAll()
                
                // 将保存的项目转换为ClipboardContent对象并添加到历史记录
                for item in savedItems {
                    let content = item.toClipboardContent()
                    clipboardHistory.append(content)
                    print("加载项目: id=\(content.id), text=\(content.text ?? "无文本"), isPinned=\(content.isPinned)")
                }
                
                // 添加日志以检查钉选项目
                let pinnedItems = clipboardHistory.filter { $0.isPinned }
                print("加载了 \(pinnedItems.count) 个钉选项目")
            } else {
                print("数据库中没有保存的剪贴板项目")
            }
        } catch {
            print("加载保存的剪贴板项目时出错: \(error.localizedDescription)")
        }
    }
    
    // 临时加载一些演示数据
    private func loadDemoData() {
        let now = Date()
        clipboardHistory.append(ClipboardContent(id: UUID(), text: "* 支持无限历史记录\n* 提供智能分类功能...", timestamp: now.addingTimeInterval(-60)))
        clipboardHistory.append(ClipboardContent(id: UUID(), text: "剪切板和复制的历史记录保持。因为我发现macos无法像windows一样打开历史剪切板", timestamp: now.addingTimeInterval(-120)))
        clipboardHistory.append(ClipboardContent(id: UUID(), text: "ardItem.self, // 使用新的剪贴板项目模型", timestamp: now.addingTimeInterval(-180)))
        clipboardHistory.append(ClipboardContent(id: UUID(), text: "https://github.com/example/clipboard-history", timestamp: now.addingTimeInterval(-240)))
    }
    
    // 开始监控剪贴板变化
    func startMonitoring() {
        if timer != nil {
            timer?.invalidate()
            timer = nil
        }
        
        isMonitoring = true
        
        // 设置定时检查
        timer = Timer.scheduledTimer(withTimeInterval: monitoringInterval, repeats: true) { [weak self] _ in
            self?.checkClipboard()
        }
    }
    
    // 停止监控剪贴板
    func stopMonitoring() {
        timer?.invalidate()
        timer = nil
        isMonitoring = false
    }
    
    // 设置监控间隔
    func setMonitoringInterval(_ interval: Double) {
        print("更新监控间隔: \(monitoringInterval) -> \(interval)秒")
        monitoringInterval = interval
        
        // 重置上次处理时间，使间隔更改立即生效
        lastProcessTime = Date().addingTimeInterval(-interval)
        
        if isMonitoring {
            startMonitoring() // 重启定时器以应用新间隔
        }
        
        // 保存设置到UserDefaults
        UserDefaults.standard.set(interval, forKey: "monitoringInterval")
    }
    
    // 打开设置
    func showSettings() {
        // 检查是否已经有设置窗口存在
        for window in NSApplication.shared.windows {
            if window.title == "FishPaste 设置" {
                window.makeKeyAndOrderFront(nil)
                NSApp.activate(ignoringOtherApps: true)
                return
            }
        }
        
        // 创建并显示设置窗口
        let settingsWindow = NSWindow(
            contentRect: NSRect(x: 0, y: 0, width: 650, height: 480),
            styleMask: [.titled, .closable, .miniaturizable],
            backing: .buffered,
            defer: false
        )
        settingsWindow.center()
        settingsWindow.title = "FishPaste 设置"
        
        // 刷新排除应用列表
        loadExcludedApps()
        
        // 创建设置视图
        let settingsView = SettingsView(clipboardManager: self)
        
        // 设置窗口内容
        let hostingView = NSHostingView(rootView: settingsView)
        settingsWindow.contentView = hostingView
        
        // 显示窗口
        settingsWindow.makeKeyAndOrderFront(nil)
        NSApp.activate(ignoringOtherApps: true)
        
        // 保持窗口引用以防止过早释放
        FishPasteApp.activeWindows.append(settingsWindow)
    }
    
    // 检查剪贴板是否有新内容
    private func checkClipboard() {
        let pasteboard = NSPasteboard.general
        let changeCount = pasteboard.changeCount
        let currentTime = Date()
        
        // 如果启用了强制iOS检测，打印状态
        if let forceUntil = forceIOSDetectionUntil, forceUntil > currentTime {
            let remainingTime = forceUntil.timeIntervalSince(currentTime)
            print("强制iOS内容检测模式已启用，剩余: \(String(format: "%.1f", remainingTime))秒")
        }
        
        // 剪贴板变化时处理
        if changeCount != lastChangeCount {
            // 检查当前应用是否在排除列表中
            if isCurrentAppExcluded() {
                print("当前应用在排除列表中，忽略此次剪贴板变化")
                lastChangeCount = changeCount // 更新计数器，避免重复处理
                return
            }
            
            // 检查时间间隔
            let elapsedTime = currentTime.timeIntervalSince(lastProcessTime)
            
            // 如果时间间隔不足，跳过此次处理
            if elapsedTime < monitoringInterval {
                print("监测到变化但间隔小于\(monitoringInterval)秒 (实际\(elapsedTime)秒)，忽略此次变化")
                // 仅更新changeCount，等待下次检查
                lastChangeCount = changeCount
                return
            }
            
            // 更新处理时间和计数器
            lastProcessTime = currentTime
            lastChangeCount = changeCount
            print("检测到剪贴板变化，尝试处理内容")
            
            // 如果有内部复制操作标记且超过5秒，强制重置
            if isInternalCopyOperation && (lastInternalCopyTime == nil || currentTime.timeIntervalSince(lastInternalCopyTime!) > 5.0) {
                print("内部复制标记超时，强制重置")
                isInternalCopyOperation = false
            }
            
            // 检查是否与Handoff事件相关 - 新增
            handlePasteboardChange()
            
            // 检测是否是通用剪贴板内容 - 启发式检测
            var isFromiOSDevice = false
            
            // 1. 检查内容是否在应用切换后很快变化 (通用剪贴板特征)
            if continueFromUniversalClipboard {
                let currentText = pasteboard.string(forType: .string)
                // 如果内容变化了并且不是从内部复制的
                if currentText != lastPasteboardText && !isInternalCopyOperation {
                    print("在应用切换后检测到剪贴板内容变化，这可能是通用剪贴板同步")
                    isFromiOSDevice = true
                    
                    // 检查最近的应用切换时间
                    if !recentChangeTimestamps.isEmpty {
                        let latestChangeTime = recentChangeTimestamps.last!
                        let timeSinceLastChange = currentTime.timeIntervalSince(latestChangeTime)
                        print("距离上次应用切换的时间: \(timeSinceLastChange)秒")
                        
                        // 通用剪贴板内容通常在应用切换后2秒内到达
                        if timeSinceLastChange < 2.0 {
                            print("确认为通用剪贴板同步的内容 (时间模式匹配)")
                            isFromiOSDevice = true
                        }
                    }
                }
                // 重置标志
                continueFromUniversalClipboard = false
            }
            
            // 2. 检查剪贴板项目类型
            if let pbItems = pasteboard.pasteboardItems {
                let allTypes = pbItems.flatMap { item -> [String] in
                    return (item.types as? [String]) ?? []
                }
                
                // 输出所有类型
                print("剪贴板包含类型: \(allTypes.joined(separator: ", "))")
                
                // 检查特定的iOS标识符
                let universalTypes = [
                    "com.apple.handoff.transport",
                    "com.apple.mobileme.sync",
                    "com.apple.pasteboard.promised-file-content-type",
                    "com.apple.pasteboard.clipboard-type",
                    "dyn.ah62d4rv4gu8y6y4usm1044pxqzb085xyqc"
                ]
                
                for type in allTypes {
                    if universalTypes.contains(type) || type.contains("handoff") || type.contains("mobileme") {
                        print("检测到通用剪贴板特征类型: \(type)")
                        isFromiOSDevice = true
                        break
                    }
                }
            }
            
            // 尝试提取剪贴板内容
            if let content = extractClipboardContent() {
                // 如果检测到来自iOS设备，处理
                if isFromiOSDevice {
                    print("确认内容来自iOS设备")
                    // 显式设置来源为iOS设备
                    content.sourceDevice = .iOS
                    content.sourceApp = ("com.apple.mobileclipboard", "iOS设备", nil)
                    
                    // 检查是否需要根据规则忽略iOS内容
                    if ignoreIosData {
                        print("根据规则忽略来自iOS设备的内容")
                        return
                    }
                }
                
                // 检查内容是否符合规则
                if !contentPassesRules(content) {
                    print("根据规则忽略此次剪贴板内容")
                    return
                }
                
                // 设置当前提取的内容
                currentClipboardContent = content
                
                // 如果是内部复制操作且时间在1秒内，跳过
                if isInternalCopyOperation {
                    let now = Date()
                    if let lastTime = lastInternalCopyTime, now.timeIntervalSince(lastTime) < 1.0 {
                        print("跳过内部复制操作处理")
                        return
                    }
                    
                    // 超过1秒，重置标记
                    isInternalCopyOperation = false
                    print("重置内部复制标记")
                }
                
                // 处理剪贴板内容
                processClipboardContent()
            } else {
                print("无法从剪贴板提取有效内容")
            }
        }
    }
    
    // 从剪贴板提取内容
    private func extractClipboardContent() -> ClipboardContent? {
        let pasteboard = NSPasteboard.general
        
        // 创建新的剪贴板内容对象
        let content = ClipboardContent()
        content.id = UUID()
        content.timestamp = Date()
        
        // 检查是否处于强制iOS检测模式，或者是否检测到最近的Handoff事件
        var sourceIsIOS = false
        if let forceUntil = forceIOSDetectionUntil, forceUntil > Date() {
            print("当前处于强制iOS检测模式")
            sourceIsIOS = true
        } else if let handoffTime = handoffDetectedTime, 
                  Date().timeIntervalSince(handoffTime) < 5.0 {
            print("最近5秒内检测到Handoff事件，可能是iOS设备内容")
            sourceIsIOS = true
        } else {
            // 正常检测逻辑 - 检查剪贴板类型等
            print("检查剪贴板项目类型...")
            
            // 定义更完整的iOS设备特征类型列表
            let iosSignatureTypes = [
                // Handoff相关
                "com.apple.handoff.transport",
                "com.apple.handoff.content",
                "com.apple.handoff.clipboard",
                "com.apple.handoff.clipboard.pasteboard",
                
                // MobilMe/iCloud相关
                "com.apple.mobileme.sync",
                "com.apple.CloudKit",
                "com.apple.icloud",
                
                // 通用剪贴板相关
                "com.apple.pasteboard.promised-file-content-type",
                "com.apple.pasteboard.clipboard-type",
                "com.apple.NSPasteboardTypeUniversalClipboard",
                
                // 系统剪贴板
                "com.apple.pasteboard",
                "com.apple.ios.pasteboard",
                
                // 动态类型 (常见于iOS设备)
                "dyn.ah62d4rv4gu8y6y4usm1044pxqzb085xyqc",
                "dyn.ah62d4rv4gu8yc6durvwwa3xmrvw1gkdusm1044pxqzb085xyqc",
                
                // UIKit类型
                "com.apple.uikit.image",
                "com.apple.uikit.text",
                "com.apple.uikit.pasteboard"
            ]
            
            if let pbItems = pasteboard.pasteboardItems {
                print("发现 \(pbItems.count) 个剪贴板项目")
                
                // 遍历剪贴板项目
                for (index, item) in pbItems.enumerated() {
                    print("检查第 \(index + 1) 个项目:")
                    
                    if let types = item.types as? [String] {
                        // 输出所有类型用于调试
                        print("项目类型: \(types.joined(separator: ", "))")
                        
                        // 检查是否包含iOS特征类型
                        for type in types {
                            // 直接匹配iOS特征类型
                            if iosSignatureTypes.contains(type) {
                                print("直接匹配到iOS设备特征类型: \(type)")
                                sourceIsIOS = true
                                break
                            }
                            
                            // 模糊匹配iOS相关关键词
                            if type.contains("handoff") || 
                               type.contains("apple") && (type.contains("mobile") || type.contains("ios") || type.contains("uikit")) ||
                               type.contains("icloud") ||
                               type.contains("universal") && type.contains("clipboard") {
                                print("模糊匹配到iOS设备相关类型: \(type)")
                                sourceIsIOS = true
                                break
                            }
                        }
                        
                        if sourceIsIOS {
                            break
                        }
                    }
                    
                    // 检查项目数据中的iOS特征
                    if let data = item.data(forType: .string) {
                        print("检查项目数据内容特征")
                        if let str = String(data: data, encoding: .utf8) {
                            if str.contains("UIPasteboard") || 
                               str.contains("UIKit") || 
                               str.contains("iPhone") || 
                               str.contains("iPad") ||
                               str.contains("iOS") && str.contains("Device") {
                                print("在数据内容中检测到iOS设备特征")
                                sourceIsIOS = true
                                break
                            }
                        }
                    }
                }
                
                // 尝试检查特殊属性值
                if !sourceIsIOS {
                    for pbItem in pbItems {
                        // 检查是否有特殊的属性提示内容来源
                        if let origin = pbItem.string(forType: NSPasteboard.PasteboardType(rawValue: "com.apple.pasteboard.source")) {
                            if origin.contains("iOS") || origin.contains("iPhone") || origin.contains("iPad") {
                                print("从来源属性检测到iOS设备: \(origin)")
                                sourceIsIOS = true
                                break
                            }
                        }
                    }
                }
            }
        }
        
        // 设置内容来源
        if sourceIsIOS {
            content.sourceDevice = .iOS
            content.sourceApp = ("com.apple.mobileclipboard", "iOS设备", nil)
            print("内容来源已设置为iOS设备")
        } else {
            let sourceAppInfo = getCurrentApplicationInfo()
            content.sourceApp = (sourceAppInfo.bundleIdentifier, sourceAppInfo.name, getAppIcon(for: sourceAppInfo.bundleIdentifier))
            content.sourceDevice = .macOS
        }
        
        // 提取文本内容
        if let text = pasteboard.string(forType: .string) {
            content.text = text
            content.dataSize = text.utf8.count
            print("提取到文本内容，长度: \(text.count) 字符")
        }
        
        // 提取图像内容
        if let image = NSImage(pasteboard: pasteboard) {
            content.image = image
            if let tiffData = image.tiffRepresentation {
                content.dataSize = tiffData.count
                print("提取到图片内容，大小: \(tiffData.count) 字节")
            }
        }
        
        // 提取文件URL
        if let fileURLs = pasteboard.readObjects(forClasses: [NSURL.self]) as? [URL], !fileURLs.isEmpty {
            content.fileURLs = fileURLs
            content.dataSize = fileURLs.reduce(0) { total, url in
                do {
                    let attributes = try FileManager.default.attributesOfItem(atPath: url.path)
                    if let size = attributes[.size] as? Int {
                        return total + size
                    }
                } catch {
                    print("无法获取文件大小: \(error)")
                }
                return total
            }
            print("提取到 \(fileURLs.count) 个文件URL")
        }
        
        // 检查内容是否为空
        if content.text == nil && content.image == nil && (content.fileURLs == nil || content.fileURLs!.isEmpty) {
            print("未提取到任何有效内容")
            return nil
        }
        
        // 确定内容类别
        determineContentCategory(for: content)
        
        // 打印设备来源信息
        print("剪贴板内容来源设备: \(content.sourceDevice)")
        print("剪贴板内容来源应用: \(content.sourceApp?.name ?? "未知")")
        
        return content
    }
    
    // 确定内容类别
    private func determineContentCategory(for content: ClipboardContent) {
        // 根据内容特征设置类别
        if content.image != nil || (content.images != nil && !content.images!.isEmpty) {
            content.category = "image"
        } else if let text = content.text {
            if text.hasPrefix("http://") || text.hasPrefix("https://") {
                content.category = "url"
            } else if text.contains("\n") || text.count > 100 {
                content.category = "text"
            } else {
                content.category = "snippet"
            }
        } else if content.fileURLs != nil && !content.fileURLs!.isEmpty {
            content.category = "file"
        } else {
            content.category = "other"
        }
    }
    
    // 保存内容到数据库
    private func saveContentToDatabase(_ content: ClipboardContent) {
        guard let modelContext = modelContext else { 
            print("警告: 模型上下文未初始化，数据未保存") 
            return 
        }
        
        // 安全处理单个图像数据
        var imageData: Data? = nil
        if let image = content.image {
            // 尝试获取更可靠的PNG表示而非TIFF
            if let tiffData = image.tiffRepresentation,
               let bitmap = NSBitmapImageRep(data: tiffData),
               let pngData = bitmap.representation(using: .png, properties: [:]) {
                imageData = pngData
            }
        }
        
        // 处理多个图像数据
        var imagesData: [Data]? = nil
        if let images = content.images, !images.isEmpty {
            imagesData = []
            for img in images {
                if let tiffData = img.tiffRepresentation,
                   let bitmap = NSBitmapImageRep(data: tiffData),
                   let pngData = bitmap.representation(using: .png, properties: [:]) {
                    imagesData?.append(pngData)
                }
            }
        }
        
        // 提取应用信息
        let sourceBundleID = content.sourceApp?.bundleIdentifier
        let sourceAppName = content.sourceApp?.name
        
        // 创建数据库项目
        let item = ClipboardItem(
            id: content.id,
            textContent: content.text,
            imageData: imageData,
            imagesData: imagesData,
            fileURLStrings: content.fileURLs?.map { $0.absoluteString },
            category: content.category,
            timestamp: content.timestamp,
            isPinned: content.isPinned,
            title: content.title,
            sourceAppBundleID: sourceBundleID,
            sourceAppName: sourceAppName
        )
        
        // 将项目添加到持久存储
        modelContext.insert(item)
        
        // 尝试保存更改
        do {
            try modelContext.save()
            print("成功保存新项目到数据库: id=\(content.id)")
        } catch {
            print("保存到数据库时出错: \(error.localizedDescription)")
        }
    }
    
    // 从数据库中删除项目
    private func deleteItemFromDatabase(with id: UUID) {
        guard let modelContext = modelContext else {
            print("警告: 无法删除项目，模型上下文未初始化")
            return
        }
        
        do {
            // 创建查询来找到相应的数据库记录
            let predicate = #Predicate<ClipboardItem> { item in
                item.id == id
            }
            let descriptor = FetchDescriptor<ClipboardItem>(predicate: predicate)
            
            // 尝试查找并删除项目
            if let itemToDelete = try modelContext.fetch(descriptor).first {
                modelContext.delete(itemToDelete)
                try modelContext.save()
                print("成功从数据库中删除ID为 \(id) 的项目")
            } else {
                print("警告: 在数据库中找不到ID为 \(id) 的项目")
            }
        } catch {
            print("从数据库删除项目时出错: \(error.localizedDescription)")
        }
    }
    
    // 处理剪贴板内容
    private func processClipboardContent() {
        // 重要：提前打印内部复制状态，方便调试
        print("处理剪贴板内容: 内部复制状态=\(isInternalCopyOperation)")
        
        // 如果是内部复制操作且时间在1秒内，跳过
        if isInternalCopyOperation {
            let now = Date()
            if let lastTime = lastInternalCopyTime, now.timeIntervalSince(lastTime) < 1.0 {
                print("跳过内部复制操作处理")
                return
            }
            
            // 超过1秒，重置标记
            isInternalCopyOperation = false
            print("重置内部复制标记")
        }
        
        let pasteboard = NSPasteboard.general
        
        // 获取当前活跃的应用信息
        let sourceAppInfo = getCurrentApplicationInfo()
        let sourceBundleID = sourceAppInfo.bundleIdentifier
        let sourceAppName = sourceAppInfo.name
        print("检测到内容来源应用: \(sourceAppName ?? "未知"), ID: \(sourceBundleID ?? "未知")")
        
        // 检查是否来自iOS设备
        if let content = currentClipboardContent, content.sourceDevice == .iOS {
            print("检测到来自iOS设备的内容，根据规则处理")
            if ignoreIosData {
                print("已启用忽略iOS设备内容规则，跳过处理")
                return
            }
        }
        
        // === 获取文件URL ===
        if let fileURLs = pasteboard.readObjects(forClasses: [NSURL.self]) as? [URL], !fileURLs.isEmpty {
            // 检查是否有多个不同类型的文件
            if fileURLs.count > 1 {
                // 按文件类型分组
                let filesByExtension = Dictionary(grouping: fileURLs) { url -> String in
                    return url.pathExtension.lowercased()
                }
                
                // 如果有多种不同类型的文件，为每种类型创建单独的条目
                if filesByExtension.count > 1 {
                    print("检测到\(filesByExtension.count)种不同类型的文件，创建多个条目")
                    
                    // 为每种文件类型创建单独的剪贴板条目
                    for (fileExtension, urls) in filesByExtension {
                        let content = ClipboardContent()
                        content.id = UUID()
                        content.timestamp = Date()
                        content.fileURLs = urls
                        content.sourceApp = (sourceBundleID, sourceAppName, getAppIcon(for: sourceBundleID))
                        
                        // 设置类别
                        determineContentCategory(for: content)
                        
                        // 添加到历史记录前面
                        clipboardHistory.insert(content, at: 0)
                        
                        // 保存到数据库
                        saveContentToDatabase(content)
                        
                        print("为\(fileExtension)类型创建了独立条目，包含\(urls.count)个文件")
                    }
                    
                    // 限制历史记录大小
                    limitHistorySize()
                    
                    // 播放音效
                    if !isInternalCopyOperation {
                        playClipboardChangedSound()
                    }
                    
                    // 发送通知以刷新UI
                    NotificationCenter.default.post(
                        name: Notification.Name("ClipboardContentChanged"),
                        object: nil
                    )
                    
                    return // 处理完多个文件后直接返回
                }
            }
        }
        
        // 创建剪贴板内容对象（用于单一内容类型的情况）
        let content = ClipboardContent()
        content.id = UUID()  // 生成唯一ID
        content.timestamp = Date() // 设置当前时间
        content.sourceApp = (sourceBundleID, sourceAppName, getAppIcon(for: sourceBundleID))
        
        // 标志是否找到内容
        var hasContent = false
        
        // === 获取剪贴板文本 ===
        if let text = pasteboard.string(forType: .string), !text.isEmpty {
            content.text = text
            hasContent = true
            print("从剪贴板读取文本: \(text.prefix(min(20, text.count)))...")
            
            // 检测HEX颜色代码（如果功能已启用）
            if hexColorRecognitionEnabled {
                if let hexColors = detectHEXColorCodes(in: text) {
                    print("检测到\(hexColors.count)个HEX颜色代码")
                    
                    // 存储检测到的颜色信息
                    var hexColorData: [String: [String: Any]] = [:]
                    
                    for (index, colorInfo) in hexColors.enumerated() {
                        let colorCode = colorInfo.0
                        let color = colorInfo.1
                        
                        // 将颜色信息存储为字典
                        hexColorData["\(index)"] = [
                            "code": colorCode,
                            "red": color.redComponent,
                            "green": color.greenComponent,
                            "blue": color.blueComponent,
                            "alpha": color.alphaComponent
                        ]
                    }
                    
                    // 将颜色信息保存到剪贴板内容的元数据中
                    content.metadata["hexColors"] = hexColorData
                }
            }
        }
        
        // === 获取剪贴板图片 ===
        if let images = pasteboard.readObjects(forClasses: [NSImage.self]) as? [NSImage], !images.isEmpty {
            if images.count == 1 {
                content.image = images[0]
            } else {
                content.images = images
            }
            hasContent = true
            print("从剪贴板读取\(images.count)张图片")
        }
        
        // === 获取文件URL（单一类型或单个文件的情况）===
        if let fileURLs = pasteboard.readObjects(forClasses: [NSURL.self]) as? [URL], !fileURLs.isEmpty {
            content.fileURLs = fileURLs
            hasContent = true
            print("从剪贴板读取\(fileURLs.count)个文件URL")
        }
        
        // 如果找到内容，添加到历史记录
        if hasContent {
            // 检查是否已经存在相同内容（只检查最近10条记录提高性能）
            let isDuplicate = clipboardHistory.prefix(10).contains { existingContent in
                // 1. 检查ID
                if existingContent.id == content.id {
                    return true
                }
                
                // 2. 检查文本
                if let newText = content.text, let existingText = existingContent.text, newText == existingText {
                    print("检测到重复文本，跳过添加")
                    return true
                }
                
                // 3. 简单检查图片 - 只比较第一张图片尺寸
                if let newImage = content.image, let existingImage = existingContent.image,
                   abs(newImage.size.width - existingImage.size.width) < 1 &&
                   abs(newImage.size.height - existingImage.size.height) < 1 {
                    print("检测到可能重复图片，跳过添加")
                    return true
                }
                
                return false
            }
            
            if !isDuplicate {
                print("添加新内容到历史记录")
                
                // 设置类别
                determineContentCategory(for: content)
                
                // 添加到历史记录前面
                clipboardHistory.insert(content, at: 0)
                
                // 保存到数据库
                saveContentToDatabase(content)
                
                // 限制历史记录大小
                limitHistorySize()
                
                // 播放音效
                if !isInternalCopyOperation {
                    playClipboardChangedSound()
                }
                
                // 更新最后处理的内容ID
                lastProcessedContentID = content.id
                
                // 发送通知以刷新UI
                NotificationCenter.default.post(
                    name: Notification.Name("ClipboardContentChanged"),
                    object: nil
                )
            } else {
                print("跳过添加重复内容")
            }
        } else {
            print("未发现可添加内容")
        }
    }
    
    // 限制历史记录大小的辅助方法
    private func limitHistorySize() {
        if clipboardHistory.count > maxHistorySize {
            // 移除非钉选的最旧项目
            let nonPinnedItems = clipboardHistory.filter { !$0.isPinned }
            if let oldestNonPinned = nonPinnedItems.last {
                if let index = clipboardHistory.firstIndex(where: { $0.id == oldestNonPinned.id }) {
                    // 从内存中移除
                    let removedItem = clipboardHistory.remove(at: index)
                    
                    // 从数据库中删除
                    deleteItemFromDatabase(with: removedItem.id)
                }
            }
        }
    }
    
    // 辅助方法: 创建安全图像拷贝
    private func createSafeImage(from image: NSImage) -> NSImage? {
        guard let tiffData = image.tiffRepresentation else {
            return nil
        }
        
        // 创建新的图像实例
        if let newImage = NSImage(data: tiffData) {
            // 如果启用了GPU加速，使用GPU处理图像
            if imageProcessingConfig.useGPU {
                return processImageWithGPUIfEnabled(newImage)
            }
            return newImage
        }
        
        return nil
    }
    
    // 辅助方法: 检查图像是否重复
    private func isDuplicateImage(_ newImage: NSImage, in existingImages: [NSImage]) -> Bool {
        guard let newTiff = newImage.tiffRepresentation else {
            return false
        }
        
        for existingImage in existingImages {
            if let existingTiff = existingImage.tiffRepresentation,
               newTiff == existingTiff {
                return true
            }
        }
        return false
    }
    
    // 辅助方法: 检查文件是否是图片
    private func isImageFile(_ path: String) -> Bool {
        let imageExtensions = ["png", "jpg", "jpeg", "gif", "bmp", "tiff", "webp", "heic"]
        let pathExtension = URL(fileURLWithPath: path).pathExtension.lowercased()
        return imageExtensions.contains(pathExtension)
    }
    
    // 辅助方法: 检查路径是否是目录
    private func isDirectory(at path: String) -> Bool {
        var isDir: ObjCBool = false
        let exists = FileManager.default.fileExists(atPath: path, isDirectory: &isDir)
        return exists && isDir.boolValue
    }
    
    // 辅助方法: 获取文件图标或预览
    private func getFileIconOrPreview(for url: URL) -> NSImage {
        let path = url.path
        
        // 检查是否是目录
        if isDirectory(at: path) {
            let folderIcon = NSWorkspace.shared.icon(forFile: path)
            folderIcon.size = NSSize(width: 64, height: 64)
            return folderIcon
        }
        
        // 始终返回文件关联的应用程序图标 - 不再返回图片内容
        let icon = NSWorkspace.shared.icon(forFile: path)
        icon.size = NSSize(width: 64, height: 64)
        
        return icon
    }
    
    // 辅助方法: 获取文件类型描述
    private func getFileTypeDescription(for url: URL) -> String {
        let fileExtension = url.pathExtension.lowercased()
        
        // 文件类型和描述的映射
        let fileTypeMap: [String: String] = [
            // 文档类型
            "pdf": "PDF 文档",
            "doc": "Word 文档",
            "docx": "Word 文档",
            "xls": "Excel 表格",
            "xlsx": "Excel 表格",
            "ppt": "PowerPoint 演示文稿",
            "pptx": "PowerPoint 演示文稿",
            "txt": "文本文件",
            "rtf": "富文本文件",
            "md": "Markdown 文件",
            
            // 图片类型
            "jpg": "JPEG 图片",
            "jpeg": "JPEG 图片",
            "png": "PNG 图片",
            "gif": "GIF 图片",
            "bmp": "BMP 图片",
            "tiff": "TIFF 图片",
            "webp": "WebP 图片",
            "heic": "HEIC 图片",
            
            // 压缩文件
            "zip": "ZIP 压缩文件",
            "rar": "RAR 压缩文件",
            "7z": "7z 压缩文件",
            "tar": "TAR 归档文件",
            "gz": "GZ 压缩文件",
            
            // 代码和开发文件
            "swift": "Swift 源文件",
            "java": "Java 源文件",
            "py": "Python 源文件",
            "js": "JavaScript 源文件",
            "html": "HTML 文件",
            "css": "CSS 样式表",
            "json": "JSON 数据文件",
            "xml": "XML 数据文件",
            
            // 多媒体文件
            "mp3": "MP3 音频文件",
            "mp4": "MP4 视频文件",
            "mov": "QuickTime 视频",
            "avi": "AVI 视频文件",
            "wav": "WAV 音频文件",
            
            // 其他常见类型
            "app": "应用程序",
            "dmg": "磁盘映像文件",
            "iso": "ISO 镜像文件"
        ]
        
        // 返回匹配的文件类型描述，或使用默认格式
        if let typeDescription = fileTypeMap[fileExtension] {
            return typeDescription
        } else if fileExtension.isEmpty {
            // 没有扩展名的文件
            return "无扩展名文件"
        } else {
            // 未知扩展名，以大写形式显示
            return "\(fileExtension.uppercased()) 文件"
        }
    }
    
    // 复制多个项目到剪贴板
    func copyMultipleToClipboard(_ items: [ClipboardContent]) {
        // 设置内部复制标志，避免自我检测
        isInternalCopyOperation = true
        lastInternalCopyTime = Date()
        
        // 收集所有文本、图片和文件URL
        var allTexts: [String] = []
        var allImages: [NSImage] = []
        var allFileURLs: [URL] = []
        
        for item in items {
            if let text = item.text, !text.isEmpty {
                // 确保没有重复的文本
                if !allTexts.contains(text) {
                    allTexts.append(text)
                }
            }
            
            if let image = item.image {
                // 创建图像的安全副本
                if let safeImage = createSafeImage(from: image) {
                    allImages.append(safeImage)
                }
            }
            
            if let images = item.images, !images.isEmpty {
                for img in images {
                    if let safeImage = createSafeImage(from: img) {
                        allImages.append(safeImage)
                    }
                }
            }
            
            if let fileURLs = item.fileURLs, !fileURLs.isEmpty {
                // 过滤有效的文件URL
                let validURLs = fileURLs.filter { url in
                    let path = url.path
                    return FileManager.default.fileExists(atPath: path)
                }
                allFileURLs.append(contentsOf: validURLs)
            }
        }
        
        // 准备保存结果
        let combinedItem = ClipboardContent(id: UUID())
        var success = false
        
        // 方法1: 尝试一次性写入所有对象
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        
        // 如果只有文本，优先使用纯文本格式
        if !allTexts.isEmpty && allImages.isEmpty && allFileURLs.isEmpty {
            let combinedText = allTexts.joined(separator: "\n\n----------\n\n")
            pasteboard.setString(combinedText, forType: .string)
            combinedItem.text = combinedText
            success = true
            print("方法1: 成功写入\(allTexts.count)个文本到剪贴板")
        }
        // 如果只有图片，优先使用图片格式
        else if allTexts.isEmpty && !allImages.isEmpty && allFileURLs.isEmpty {
            let result = pasteboard.writeObjects(allImages as [NSPasteboardWriting])
            if result {
                // 为单张图片使用image属性，为多张图片使用images属性
                if allImages.count == 1 {
                    combinedItem.image = allImages[0]
                } else {
                    combinedItem.images = allImages
                }
                success = true
                print("方法1: 成功写入\(allImages.count)张图片到剪贴板")
            }
        }
        // 如果只有文件URL，优先使用URL格式
        else if allTexts.isEmpty && allImages.isEmpty && !allFileURLs.isEmpty {
            let result = pasteboard.writeObjects(allFileURLs as [NSPasteboardWriting])
            if result {
                combinedItem.fileURLs = allFileURLs
                success = true
                print("方法1: 成功写入\(allFileURLs.count)个文件URL到剪贴板")
            }
        }
        // 处理混合内容类型
        else {
            var objectsToWrite: [NSPasteboardWriting] = []
            
            // 如果有文本，创建属性字符串
            if !allTexts.isEmpty {
                let combinedText = allTexts.joined(separator: "\n\n----------\n\n")
                objectsToWrite.append(combinedText as NSString)
                combinedItem.text = combinedText
            }
            
            // 添加所有图片
            objectsToWrite.append(contentsOf: allImages as [NSPasteboardWriting])
            
            // 添加所有文件URL
            objectsToWrite.append(contentsOf: allFileURLs as [NSPasteboardWriting])
            
            // 尝试写入所有对象
            let result = pasteboard.writeObjects(objectsToWrite)
            if result {
                // 根据内容类型设置组合项目的属性
                if !allImages.isEmpty {
                    if allImages.count == 1 {
                        combinedItem.image = allImages[0]
                    } else {
                        combinedItem.images = allImages
                    }
                }
                
                if !allFileURLs.isEmpty {
                    combinedItem.fileURLs = allFileURLs
                }
                
                success = true
                print("方法1: 成功写入混合内容到剪贴板")
            }
        }
        
        // 如果成功，添加到历史记录
        if success {
            DispatchQueue.main.async { [weak self] in
                guard let self = self else { return }
                self.clipboardHistory.insert(combinedItem, at: 0)
                
                // 保存到数据库
                if self.modelContext != nil {
                    self.saveContentToDatabase(combinedItem)
                }
                
                // 播放手动复制的音效
                self.playManualCopySound()
                
                // 发送通知以刷新UI
                NotificationCenter.default.post(
                    name: Notification.Name("ClipboardContentChanged"),
                    object: nil
                )
            }
        } else {
            print("所有写入方法都失败")
        }
    }
    
    // 从剪贴板历史中复制项目到当前剪贴板
    func copyToClipboard(_ content: ClipboardContent) {
        // 设置内部复制标志
        isInternalCopyOperation = true
        lastInternalCopyTime = Date()
        
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        var writeSuccess = false
        
        // 尝试各种写入方法，确保内容成功复制到剪贴板
        
        // 1. 尝试文本写入
        if let text = content.text {
            if pasteboard.setString(text, forType: .string) {
                print("成功写入文本到剪贴板")
                writeSuccess = true
            }
        }
        
        // 2. 尝试图片写入
        if let image = content.image {
            // 如果文本复制成功，添加图片而不清除
            if writeSuccess {
                // 添加图片到已有内容
                if pasteboard.writeObjects([image]) {
                    print("成功添加图片到剪贴板（附加到文本）")
                    writeSuccess = true
                }
            } else {
                // 如果还没有成功写入，先清除内容再写入图片
                pasteboard.clearContents()
                if pasteboard.writeObjects([image]) {
                    print("成功写入图片到剪贴板")
                    writeSuccess = true
                }
            }
        }
        
        // 3. 尝试多图片写入
        if let images = content.images, !images.isEmpty {
            // 如果之前的写入已成功，添加图片而不清除
            if writeSuccess {
                for image in images {
                    if pasteboard.writeObjects([image]) {
                        print("成功添加多个图片到剪贴板")
                    }
                }
            } else {
                // 如果还没有成功写入，先清除内容再写入图片
                pasteboard.clearContents()
                if pasteboard.writeObjects(images as [NSPasteboardWriting]) {
                    print("成功写入多个图片到剪贴板")
                    writeSuccess = true
                }
            }
        }
        
        // 4. 尝试文件URL写入
        if let fileURLs = content.fileURLs, !fileURLs.isEmpty {
            // 如果之前的写入已成功，添加URL而不清除
            if writeSuccess {
                if pasteboard.writeObjects(fileURLs as [NSPasteboardWriting]) {
                    print("成功添加文件URL到剪贴板")
                }
            } else {
                // 如果还没有成功写入，先清除内容再写入URL
                pasteboard.clearContents()
                if pasteboard.writeObjects(fileURLs as [NSPasteboardWriting]) {
                    print("成功写入文件URL到剪贴板")
                    writeSuccess = true
                }
            }
        }
        
        // 播放手动复制音效
        playManualCopySound()
        
        // 更新最后处理的时间戳，避免立即重新处理
        lastProcessTime = Date()
    }
    
    // 清除所有历史记录
    func clearHistory() {
        clipboardHistory.removeAll()
        
        // 从数据库中清除所有项目
        guard let modelContext = modelContext else {
            print("警告: 无法清除数据库，模型上下文未初始化")
            return
        }
        
        do {
            // 获取所有剪贴板项目
            let descriptor = FetchDescriptor<ClipboardItem>()
            let allItems = try modelContext.fetch(descriptor)
            
            // 删除所有项目
            for item in allItems {
                modelContext.delete(item)
            }
            
            // 保存更改
            try modelContext.save()
            print("成功从数据库中清除了所有历史记录")
        } catch {
            print("清除数据库时出错: \(error.localizedDescription)")
        }
    }
    
    // 根据ID删除特定项目
    func deleteItems(withIDs ids: Set<UUID>) {
        clipboardHistory.removeAll(where: { ids.contains($0.id) })
        selectedItems.removeAll()
        
        // 从数据库中删除
        guard let modelContext = modelContext else {
            print("警告: 无法从数据库删除项目，模型上下文未初始化")
            return
        }
        
        do {
            // 对每个ID执行删除操作
            for id in ids {
                // 创建查询
                let predicate = #Predicate<ClipboardItem> { item in
                    item.id == id
                }
                let descriptor = FetchDescriptor<ClipboardItem>(predicate: predicate)
                
                // 查找项目
                if let item = try modelContext.fetch(descriptor).first {
                    // 删除项目
                    modelContext.delete(item)
                }
            }
            
            // 保存更改
            try modelContext.save()
            print("成功从数据库中删除了\(ids.count)个项目")
        } catch {
            print("从数据库删除项目时出错: \(error.localizedDescription)")
        }
    }
    
    // 根据关键词搜索历史记录
    func searchHistory(query: String) -> [ClipboardContent] {
        if query.isEmpty {
            return clipboardHistory
        }
        
        return clipboardHistory.filter { content in
            if let text = content.text, text.localizedCaseInsensitiveContains(query) {
                return true
            }
            if let urls = content.fileURLs {
                return urls.contains(where: { $0.lastPathComponent.localizedCaseInsensitiveContains(query) })
            }
            return false
        }
    }
    
    // 切换监控状态
    @objc func toggleMonitoring() {
        if isMonitoring {
            stopMonitoring()
        } else {
            startMonitoring()
        }
    }
    
    // 更新监控间隔
    @objc func updateInterval(_ sender: NSMenuItem) {
        if let interval = sender.representedObject as? Double {
            setMonitoringInterval(interval)
        }
    }
    
    // 切换启动状态
    @objc func toggleStartupLaunch() {
        let launchAtStartup = !UserDefaults.standard.bool(forKey: "launchAtStartup")
        UserDefaults.standard.set(launchAtStartup, forKey: "launchAtStartup")
        
        // 设置或移除登录项
        setLaunchAtStartup(launchAtStartup)
    }
    
    // 设置随系统启动
    func setLaunchAtStartup(_ enable: Bool) {
        // 获取应用的 Bundle ID
        guard let bundleIdentifier = Bundle.main.bundleIdentifier else {
            print("无法获取应用 Bundle ID")
            notifyUser(title: "设置失败", message: "无法获取应用标识符")
            return
        }
        
        if #available(macOS 13.0, *) {
            // 使用 macOS 13 及以上版本的新 API
            Task {
                do {
                    let service = SMAppService.mainApp
                    
                    // 获取当前状态
                    let currentStatus = service.status
                    print("当前登录项状态: \(currentStatus)")
                    
                    if enable {
                        // 注册为登录项
                        if currentStatus != .enabled {
                            try service.register()
                            print("已成功将应用设置为随系统启动")
                            notifyUser(title: "设置成功", message: "已将应用设置为随系统启动")
                        } else {
                            print("应用已设置为随系统启动")
                        }
                    } else {
                        // 取消注册为登录项
                        if currentStatus == .enabled {
                            try service.unregister()
                            print("已成功取消应用随系统启动设置")
                            notifyUser(title: "设置已关闭", message: "已取消应用随系统启动设置")
                        } else {
                            print("应用未设置为随系统启动")
                        }
                    }
                } catch {
                    print("设置登录项失败: \(error.localizedDescription)")
                    notifyUser(title: "设置失败", message: "无法\(enable ? "启用" : "禁用")随系统启动功能: \(error.localizedDescription)")
                }
            }
        } else {
            // 使用老版本的 API（已废弃但向后兼容）
            let success = SMLoginItemSetEnabled(bundleIdentifier as CFString, enable)
            if success {
                print(enable ? "已成功将应用设置为随系统启动" : "已成功取消应用随系统启动设置")
                notifyUser(title: enable ? "设置成功" : "设置已关闭", 
                           message: enable ? "已将应用设置为随系统启动" : "已取消应用随系统启动设置")
            } else {
                print("设置登录项失败")
                notifyUser(title: "设置失败", message: "无法\(enable ? "启用" : "禁用")随系统启动功能")
            }
        }
    }
    
    // 显示用户通知
    private func notifyUser(title: String, message: String) {
        DispatchQueue.main.async {
            let center = NSUserNotificationCenter.default
            let notification = NSUserNotification()
            notification.title = title
            notification.informativeText = message
            notification.soundName = NSUserNotificationDefaultSoundName
            center.deliver(notification)
        }
    }
    
    // 创建单个项目的NSItemProvider
    func createItemProvider(from item: ClipboardContent) -> NSItemProvider {
        let provider = NSItemProvider()
        
        // 处理文本内容 - 增强文本兼容性
        if let text = item.text {
            // 以标准字符串类型注册
            provider.registerObject(text as NSString as NSItemProviderWriting, visibility: .all)
            
            // 注册为明确的文本类型 - 增加多种UTType支持
            ["public.text", "public.plain-text", kUTTypePlainText as String].forEach { typeID in
                provider.registerDataRepresentation(forTypeIdentifier: typeID,
                                                  visibility: .all) { completion in
                    completion(text.data(using: .utf8), nil)
                    return nil
                }
            }
        }
        
        // 处理图片内容
        if let image = item.image, let tiffData = image.tiffRepresentation {
            // 直接注册NSImage对象
            provider.registerObject(image, visibility: .all)
            
            // 同时注册为二进制数据
            provider.registerDataRepresentation(forTypeIdentifier: kUTTypeTIFF as String,
                                              visibility: .all) { completion in
                completion(tiffData, nil)
                return nil
            }
        }
        
        // 处理文件内容 - 直接拖放文件而不是路径
        if let urls = item.fileURLs, !urls.isEmpty {
            // 注册每个单独的URL
            for url in urls {
                if FileManager.default.fileExists(atPath: url.path) {
                    // 对于每个存在的文件，尝试直接注册URL
                    provider.registerObject(url as NSURL as NSItemProviderWriting, visibility: .all)
                    
                    // 或者创建基于URL内容的provider
                    let contentProvider = NSItemProvider(contentsOf: url)
                    if let contentProvider = contentProvider {
                        return contentProvider
                    }
                }
            }
        }
        
        return provider
    }
    
    // 创建多个项目的NSItemProvider
    func createMultiItemsProvider(from items: [ClipboardContent]) -> NSItemProvider {
        let provider = NSItemProvider()
        
        // 收集所有文本内容 - 改进文本拖拽
        let texts = items.compactMap { $0.text }.joined(separator: "\n")
        if !texts.isEmpty {
            // 以标准字符串类型注册
            provider.registerObject(texts as NSString as NSItemProviderWriting, visibility: .all)
            
            // 注册为明确的文本类型 - 增加多种UTType支持
            ["public.text", "public.plain-text", kUTTypePlainText as String].forEach { typeID in
                provider.registerDataRepresentation(forTypeIdentifier: typeID,
                                                  visibility: .all) { completion in
                    completion(texts.data(using: .utf8), nil)
                    return nil
                }
            }
        }
        
        // 处理图片 - 只使用第一张图片
        if let firstImage = items.compactMap({ $0.image }).first {
            // 直接注册NSImage对象
            provider.registerObject(firstImage, visibility: .all)
            
            // 同时注册为二进制数据
            if let tiffData = firstImage.tiffRepresentation {
                provider.registerDataRepresentation(forTypeIdentifier: kUTTypeTIFF as String,
                                                  visibility: .all) { completion in
                    completion(tiffData, nil)
                    return nil
                }
            }
        }
        
        // 处理文件 - 查找所有选中项目中的文件
        let allFileURLs = items.compactMap { $0.fileURLs }.flatMap { $0 }
        if !allFileURLs.isEmpty {
            // 逐个注册有效的URL
            for url in allFileURLs {
                if FileManager.default.fileExists(atPath: url.path) {
                    provider.registerObject(url as NSURL as NSItemProviderWriting, visibility: .all)
                }
            }
            
            // 单个文件处理 - 使用专用Provider
            if let firstURL = allFileURLs.first,
               FileManager.default.fileExists(atPath: firstURL.path) {
                // 创建基于URL内容的provider
                let contentProvider = NSItemProvider(contentsOf: firstURL)
                if let contentProvider = contentProvider {
                    return contentProvider
                }
            }
        }
        
        return provider
    }
    
    // 切换项目的钉选状态并保存到数据库
    func togglePinStatus(for itemID: UUID) {
        // 查找项目并更新状态
        if let index = clipboardHistory.firstIndex(where: { $0.id == itemID }) {
            // 切换钉选状态
            clipboardHistory[index].isPinned.toggle()
            let newPinStatus = clipboardHistory[index].isPinned
            
            print("切换项目 \(itemID) 的钉选状态为: \(newPinStatus ? "钉选" : "取消钉选")")
            
            // 更新数据库中的记录
            updateItemInDatabase(clipboardHistory[index])
        }
    }
    
    // 设置项目的钉选状态并保存到数据库
    func setPinStatus(for itemID: UUID, isPinned: Bool) {
        // 查找项目并更新状态
        if let index = clipboardHistory.firstIndex(where: { $0.id == itemID }) {
            // 设置钉选状态
            clipboardHistory[index].isPinned = isPinned
            
            print("设置项目 \(itemID) 的钉选状态为: \(isPinned ? "钉选" : "取消钉选")")
            
            // 更新数据库中的记录
            updateItemInDatabase(clipboardHistory[index])
        }
    }
    
    // 更新数据库中的剪贴板项目
    private func updateItemInDatabase(_ content: ClipboardContent) {
        guard let modelContext = modelContext else {
            print("警告: 无法更新数据库，模型上下文未初始化")
            return
        }
        
        do {
            // 创建查询来找到相应的数据库记录 - 使用正确的UUID比较
            let contentID = content.id // 获取实际的UUID值
            let predicate = #Predicate<ClipboardItem> { item in
                item.id == contentID
            }
            let descriptor = FetchDescriptor<ClipboardItem>(predicate: predicate)
            
            // 查找数据库中的项目
            if let existingItem = try modelContext.fetch(descriptor).first {
                // 更新现有项目的属性
                existingItem.isPinned = content.isPinned
                existingItem.category = content.category
                
                // 如果有其他属性更改，也可以在这里更新
                existingItem.timestamp = content.timestamp
                
                // 保存更改
                try modelContext.save()
                print("成功更新数据库中的剪贴板项目: ID=\(content.id), 钉选=\(content.isPinned)")
            } else {
                print("错误: 在数据库中找不到ID为 \(content.id) 的项目")
                
                // 如果找不到，作为备选方案创建新记录
                saveToDatabase(content)
            }
        } catch {
            print("更新数据库中的剪贴板项目时出错: \(error.localizedDescription)")
        }
    }
    
    // 保存数据库更改
    private func saveToDatabase(_ content: ClipboardContent) {
        // 调用新的saveContentToDatabase函数
        saveContentToDatabase(content)
    }
    
    // 更新剪贴板项目的标题
    func updateTitle(for itemID: UUID, newTitle: String) {
        // 查找项目并更新标题
        if let index = clipboardHistory.firstIndex(where: { $0.id == itemID }) {
            // 设置新标题
            clipboardHistory[index].title = newTitle
            
            print("更新项目 \(itemID) 的标题为: \(newTitle)")
            
            // 更新数据库中的记录
            updateTitleInDatabase(itemID, newTitle: newTitle)
        }
    }
    
    // 更新剪贴板项目的文本内容
    func updateTextContent(for itemID: UUID, newText: String, newTitle: String?) {
        // 查找项目并更新内容
        if let index = clipboardHistory.firstIndex(where: { $0.id == itemID }) {
            // 设置新内容
            clipboardHistory[index].text = newText
            
            // 如果有标题也一并更新
            if let title = newTitle {
                clipboardHistory[index].title = title
            }
            
            print("更新项目 \(itemID) 的文本内容")
            
            // 更新数据库中的记录
            updateContentInDatabase(clipboardHistory[index])
            
            // 发送通知以刷新UI
            NotificationCenter.default.post(
                name: Notification.Name("ClipboardContentChanged"),
                object: nil
            )
        }
    }
    
    // 更新剪贴板项目的图片内容
    func updateImageContent(for itemID: UUID, newImage: NSImage, newTitle: String?) {
        // 查找项目并更新内容
        if let index = clipboardHistory.firstIndex(where: { $0.id == itemID }) {
            // 设置新图片
            clipboardHistory[index].image = newImage
            clipboardHistory[index].images = nil  // 清除多图片集合
            
            // 如果有标题也一并更新
            if let title = newTitle {
                clipboardHistory[index].title = title
            }
            
            print("更新项目 \(itemID) 的图片内容")
            
            // 更新数据库中的记录
            updateContentInDatabase(clipboardHistory[index])
            
            // 发送通知以刷新UI
            NotificationCenter.default.post(
                name: Notification.Name("ClipboardContentChanged"),
                object: nil
            )
        }
    }
    
    // 在数据库中更新项目标题
    private func updateTitleInDatabase(_ itemID: UUID, newTitle: String) {
        guard let modelContext = modelContext else {
            print("警告: 无法更新数据库，模型上下文未初始化")
            return
        }
        
        do {
            // 创建查询来找到相应的数据库记录
            let predicate = #Predicate<ClipboardItem> { item in
                item.id == itemID
            }
            let descriptor = FetchDescriptor<ClipboardItem>(predicate: predicate)
            
            // 查找数据库中的项目
            if let existingItem = try modelContext.fetch(descriptor).first {
                // 更新标题
                existingItem.title = newTitle
                
                // 保存更改
                try modelContext.save()
                print("成功更新数据库中的项目标题: ID=\(itemID), 新标题=\(newTitle)")
            } else {
                print("错误: 在数据库中找不到ID为 \(itemID) 的项目")
            }
        } catch {
            print("更新数据库中的项目标题时出错: \(error.localizedDescription)")
        }
    }
    
    // 在数据库中更新项目内容
    private func updateContentInDatabase(_ content: ClipboardContent) {
        guard let modelContext = modelContext else {
            print("警告: 无法更新数据库，模型上下文未初始化")
            return
        }
        
        do {
            // 创建查询来找到相应的数据库记录
            let contentID = content.id
            let predicate = #Predicate<ClipboardItem> { item in
                item.id == contentID
            }
            let descriptor = FetchDescriptor<ClipboardItem>(predicate: predicate)
            
            // 查找数据库中的项目
            if let existingItem = try modelContext.fetch(descriptor).first {
                // 更新文本内容
                existingItem.textContent = content.text
                
                // 更新标题
                existingItem.title = content.title
                
                // 更新时间戳
                existingItem.timestamp = content.timestamp
                
                // 更新图片数据
                if let image = content.image {
                    // 处理单图片
                    if let tiffData = image.tiffRepresentation,
                       let bitmap = NSBitmapImageRep(data: tiffData),
                       let pngData = bitmap.representation(using: .png, properties: [:]) {
                        existingItem.imageData = pngData
                    }
                    
                    // 清除多图片数据
                    existingItem.imagesData = nil
                } else if let images = content.images, !images.isEmpty {
                    // 处理多图片
                    var imagesData: [Data] = []
                    for img in images {
                        if let tiffData = img.tiffRepresentation,
                           let bitmap = NSBitmapImageRep(data: tiffData),
                           let pngData = bitmap.representation(using: .png, properties: [:]) {
                            imagesData.append(pngData)
                        }
                    }
                    
                    existingItem.imagesData = imagesData.isEmpty ? nil : imagesData
                    existingItem.imageData = nil
                }
                
                // 保存更改
                try modelContext.save()
                print("成功更新数据库中的项目内容: ID=\(content.id)")
            } else {
                print("错误: 在数据库中找不到ID为 \(content.id) 的项目")
                
                // 如果找不到，作为备选方案创建新记录
                saveContentToDatabase(content)
            }
        } catch {
            print("更新数据库中的项目内容时出错: \(error.localizedDescription)")
        }
    }
    
    // 获取剪贴板项目的标题
    func getItemTitle(for itemID: UUID) -> String? {
        // 查找项目并返回其标题
        if let item = clipboardHistory.first(where: { $0.id == itemID }) {
            return item.title
        }
        
        return nil
    }
    
    // 获取当前活跃应用的信息
    private func getCurrentApplicationInfo() -> (bundleIdentifier: String?, name: String?) {
        // 获取当前活跃的应用
        if let activeApp = NSWorkspace.shared.frontmostApplication {
            return (activeApp.bundleIdentifier, activeApp.localizedName)
        }
        
        // 如果无法获取活跃应用，使用默认值（当前应用）
        return (Bundle.main.bundleIdentifier, "FishPaste")
    }
    
    // 获取应用图标
    private func getAppIcon(for bundleIdentifier: String?) -> NSImage? {
        guard let bundleID = bundleIdentifier else { return nil }
        
        // 尝试获取应用图标
        if let appURL = NSWorkspace.shared.urlForApplication(withBundleIdentifier: bundleID) {
            let icon = NSWorkspace.shared.icon(forFile: appURL.path)
            return icon
        }
        
        return nil
    }
    
    // 加载排除应用列表
    private func loadExcludedApps() {
        print("ClipboardManager - 开始加载排除应用列表...")
        if let data = UserDefaults.standard.data(forKey: "excludedApps") {
            print("ClipboardManager - 找到排除应用数据，大小: \(data.count) 字节")
            do {
                // 使用相同的ExcludedApp结构进行解码
                let excludedApps = try JSONDecoder().decode([ExcludedApp].self, from: data)
                self.excludedAppBundleIds = excludedApps.map { $0.bundleIdentifier }
                print("ClipboardManager - 成功加载 \(excludedAppBundleIds.count) 个排除应用的Bundle ID")
                if !excludedAppBundleIds.isEmpty {
                    print("ClipboardManager - 排除的应用Bundle ID: \(excludedAppBundleIds.joined(separator: ", "))")
                }
            } catch {
                print("ClipboardManager - 解码排除应用列表时出错: \(error)")
                print("ClipboardManager - 错误详情: \(error.localizedDescription)")
                // 出错时设置为空列表
                self.excludedAppBundleIds = []
            }
        } else {
            print("ClipboardManager - UserDefaults中没有找到排除应用数据，使用空列表")
            self.excludedAppBundleIds = []
        }
    }
    
    // 定义与SettingsView中相同的ExcludedApp结构
    struct ExcludedApp: Codable {
        var id: UUID
        var name: String
        var bundleIdentifier: String
        var path: String
    }
    
    // 检查当前应用是否在排除列表中
    private func isCurrentAppExcluded() -> Bool {
        // 获取当前活动应用的Bundle ID
        if let currentApp = NSWorkspace.shared.frontmostApplication {
            let bundleId = currentApp.bundleIdentifier ?? ""
            
            // 检查是否在排除列表中
            if excludedAppBundleIds.contains(bundleId) {
                print("当前应用 '\(currentApp.localizedName ?? "未知")' (\(bundleId)) 在排除列表中")
                return true
            }
        }
        return false
    }
    
    // 当设置更新时重新加载排除应用列表
    func refreshExcludedApps() {
        let previousCount = excludedAppBundleIds.count
        loadExcludedApps()
        let newCount = excludedAppBundleIds.count
        print("排除应用列表已更新: \(previousCount) -> \(newCount) 个应用")
        if !excludedAppBundleIds.isEmpty {
            print("排除的应用bundleID列表: \(excludedAppBundleIds)")
        }
    }
    
    // 更新剪贴板规则
    func updateClipboardRules(rules: [String: Any]) {
        print("更新剪贴板规则: \(rules)")
        
        // 更新规则设置
        if let value = rules["ignoreIosData"] as? Bool {
            ignoreIosData = value
        }
        
        if let value = rules["ignorePrivateData"] as? Bool {
            ignorePrivateData = value
        }
        
        if let value = rules["ignoreAutoGeneratedData"] as? Bool {
            ignoreAutoGeneratedData = value
        }
        
        if let value = rules["convertLargeExcelToText"] as? Bool {
            convertLargeExcelToText = value
        }
        
        if let value = rules["ignoreSizeLimit"] as? Double {
            ignoreSizeLimit = value
        }
        
        // 通知规则更新
        NotificationCenter.default.post(name: NSNotification.Name("ClipboardRulesUpdated"), object: nil)
    }
    
    // 启用强制iOS设备检测一段时间（秒）
    func enableForceIOSDetection(forSeconds seconds: Double) {
        print("启用强制iOS设备检测 \(seconds) 秒")
        forceIOSDetectionUntil = Date().addingTimeInterval(seconds)
        
        // 发送通知以便UI可以更新
        NotificationCenter.default.post(
            name: Notification.Name("ForceIOSDetectionEnabled"),
            object: nil,
            userInfo: ["seconds": seconds]
        )
        
        // 添加一次性计时器，在时间结束后重置
        DispatchQueue.main.asyncAfter(deadline: .now() + seconds) { [weak self] in
            guard let self = self else { return }
            print("强制iOS设备检测已结束")
            self.forceIOSDetectionUntil = nil
            
            // 发送通知以便UI可以更新
            NotificationCenter.default.post(
                name: Notification.Name("ForceIOSDetectionDisabled"),
                object: nil
            )
        }
    }
    
    // 检查内容是否符合规则
    private func contentPassesRules(_ content: ClipboardContent) -> Bool {
        // 检查大小限制
        if ignoreSizeLimit > 0 {
            if let dataSize = content.dataSize, Double(dataSize) / 1024 / 1024 > ignoreSizeLimit {
                print("内容被忽略: 超过大小限制 \(ignoreSizeLimit) MB")
                return false
            }
        }
        
        // 检查iOS设备数据
        if ignoreIosData && content.sourceDevice == .iOS {
            print("内容被忽略: 来自iOS设备")
            return false
        }
        
        // 检查标记为机密的数据
        if ignorePrivateData && content.isPrivate {
            print("内容被忽略: 标记为机密")
            return false
        }
        
        // 检查自动生成的数据
        if ignoreAutoGeneratedData && content.isAutoGenerated {
            print("内容被忽略: 标记为自动生成")
            return false
        }
        
        // 检查Excel内容大小
        if convertLargeExcelToText && content.sourceApp?.name?.contains("Excel") == true {
            if let dataSize = content.dataSize, dataSize > 100 * 1024 { // 100 KB
                print("Excel内容将被转换为纯文本: 大小超过100 KB")
                // 这里只是标记需要转换，实际转换逻辑在处理剪贴板内容时执行
                content.forceConvertToPlainText = true
            }
        }
        
        return true
    }
    
    // 检查是否来自UIPasteboard的脚本工具
    func detectIOSDeviceClipboard() {
        print("开始检测来自iOS设备的剪贴板内容")
        
        // 启用5秒的强制iOS检测模式
        enableForceIOSDetection(forSeconds: 5.0)
        
        // 通知用户
        DispatchQueue.main.async {
            let notification = NSUserNotification()
            notification.title = "iOS设备检测模式已启用"
            notification.informativeText = "接下来5秒内的剪贴板内容将被视为来自iOS设备"
            notification.soundName = NSUserNotificationDefaultSoundName
            NSUserNotificationCenter.default.deliver(notification)
            
            // 也显示一个提示框
            let alert = NSAlert()
            alert.messageText = "iOS设备检测模式已启用"
            alert.informativeText = "接下来5秒内，请在iOS设备上复制内容并等待通用剪贴板同步。\n\n系统将把这段时间内的所有剪贴板内容识别为来自iOS设备。"
            alert.alertStyle = .informational
            alert.addButton(withTitle: "好的")
            
            // 创建模态窗口
            if let window = NSApp.keyWindow {
                alert.beginSheetModal(for: window) { _ in }
            } else {
                alert.runModal()
            }
        }
    }
    
    // 设置Handoff事件检测
    private func setupHandoffDetection() {
        print("开始设置Handoff和系统事件检测...")
        
        // 监听应用程序生命周期事件
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(detectHandoffAndSystemEvents),
            name: NSWorkspace.didLaunchApplicationNotification,
            object: nil
        )
        
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(detectHandoffAndSystemEvents),
            name: NSWorkspace.didActivateApplicationNotification, 
            object: nil
        )
        
        // 注册自定义的通知监听
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(applicationWillContinueUserActivity(_:)),
            name: userActivityWillContinueNotification,
            object: nil
        )
        
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(applicationDidUpdateUserActivity(_:)),
            name: userActivityDidUpdateNotification,
            object: nil
        )
        
        // 注册应用程序委托来处理Handoff
        setupAppDelegateHandoffHandling()
        
        // 获取分布式通知中心
        let distributedCenter = DistributedNotificationCenter.default()
        
        // 监听通用剪贴板和Handoff相关的系统通知
        let handoffRelatedNotifications: [Notification.Name] = [
            // 剪贴板服务通知
            Notification.Name("com.apple.pasteboard.changed"),
            Notification.Name("com.apple.Pasteboard.server.pasteboard.changed"),
            Notification.Name("com.apple.Pasteboard.client.pasteboard.changed"),
            
            // Handoff相关通知
            Notification.Name("com.apple.ServiceHub.PBCopyNotification"),
            Notification.Name("com.apple.HandoffActivated"),
            Notification.Name("com.apple.UniversalClipboard.Received"),
            
            // 系统服务通知
            Notification.Name("com.apple.sharingd.devicediscovery"),
            Notification.Name("com.apple.sharingd.HandoffClientDataChanged"),
            Notification.Name("com.apple.sharingd.deviceadded"),
            
            // Continuity相关通知
            Notification.Name("com.apple.continuity.clipboard.changed"),
            Notification.Name("com.apple.continuity.activated")
        ]
        
        // 注册所有通知
        for notificationName in handoffRelatedNotifications {
            distributedCenter.addObserver(
                self,
                selector: #selector(detectHandoffAndSystemEvents),
                name: notificationName,
                object: nil
            )
            print("已注册系统通知: \(notificationName.rawValue)")
        }
        
        print("已完成Handoff和系统事件检测设置")
    }
    
    // 设置应用程序委托处理Handoff
    private func setupAppDelegateHandoffHandling() {
        // 在应用程序委托中注册Handoff处理方法
        let notificationCenter = NotificationCenter.default
        
        // 注意：这些通知在实际使用中需要从AppDelegate转发过来
        notificationCenter.addObserver(
            forName: handoffReceivedNotification,
            object: nil,
            queue: .main
        ) { [weak self] notification in
            guard let self = self else { return }
            print("接收到Handoff通知")
            
            if let activity = notification.userInfo?["activity"] as? NSUserActivity {
                self.handleUserActivity(activity)
            }
        }
    }
    
    // 处理接收到的UserActivity
    private func handleUserActivity(_ activity: NSUserActivity) {
        print("处理UserActivity: \(activity.activityType)")
        
        // 检查是否是通用剪贴板相关活动
        if activity.activityType.contains("clipboard") || 
           activity.activityType.contains("Clipboard") || 
           activity.activityType.contains("pasteboard") ||
           activity.activityType.contains("Pasteboard") {
            
            print("检测到通用剪贴板相关活动")
            isHandoffSessionActive = true
            handoffDetectedTime = Date()
            
            // 启用iOS检测模式
            enableForceIOSDetection(forSeconds: 5.0)
            
            // 延迟检查剪贴板
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
                self?.checkClipboard()
            }
        }
    }
    
    // 监听继续用户活动通知
    @objc private func applicationWillContinueUserActivity(_ notification: Notification) {
        print("收到应用将继续用户活动通知")
        if let activityType = notification.userInfo?["NSUserActivityType"] as? String {
            print("活动类型: \(activityType)")
            
            if activityType.contains("clipboard") || activityType.contains("pasteboard") {
                print("准备接收通用剪贴板内容")
                isHandoffSessionActive = true
                handoffDetectedTime = Date()
                
                // 启用iOS检测模式
                enableForceIOSDetection(forSeconds: 5.0)
            }
        }
    }
    
    // 监听更新用户活动通知
    @objc private func applicationDidUpdateUserActivity(_ notification: Notification) {
        print("收到应用已更新用户活动通知")
        if let activity = notification.userInfo?["NSUserActivity"] as? NSUserActivity {
            print("更新的活动类型: \(activity.activityType)")
            
            // 检查是否是通用剪贴板或Handoff相关活动
            if activity.activityType.contains("clipboard") || 
               activity.activityType.contains("Clipboard") ||
               activity.activityType.contains("pasteboard") ||
               activity.activityType.contains("continuity") ||
               activity.activityType.contains("handoff") {
                
                print("检测到可能与通用剪贴板相关的活动更新")
                
                // 检查是否很快就有剪贴板变化
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
                    self?.checkClipboard()
                }
            }
        }
    }
    
    // 全局剪贴板变化检测 - 不再需要通知监听
    private func handlePasteboardChange() {
        print("检测到剪贴板变化")
        
        // 如果最近检测到Handoff事件，则标记为iOS设备内容
        if isHandoffSessionActive || 
           (handoffDetectedTime != nil && Date().timeIntervalSince(handoffDetectedTime!) < 3.0) {
            print("剪贴板变化发生在Handoff会话期间，很可能是iOS设备内容")
            enableForceIOSDetection(forSeconds: 5.0)
            
            // 延迟执行以确保剪贴板内容已完全更新
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
                self?.checkClipboard()
            }
        }
    }
    
    // 检测Handoff和系统事件
    @objc private func detectHandoffAndSystemEvents(_ notification: Notification) {
        // 获取当前时间
        let now = Date()
        
        // 提取通知信息
        let notificationName = notification.name.rawValue
        print("收到系统通知: \(notificationName)")
        
        var detectedHandoff = false
        var bundleID: String? = nil
        
        // 根据通知名称直接检测
        if notificationName.contains("pasteboard") || 
           notificationName.contains("Pasteboard") || 
           notificationName.contains("Clipboard") || 
           notificationName.contains("clipboard") || 
           notificationName.contains("Handoff") || 
           notificationName.contains("handoff") || 
           notificationName.contains("continuity") {
            
            detectedHandoff = true
            print("检测到剪贴板或Handoff相关系统通知: \(notificationName)")
        }
        
        // 应用切换检测
        if notification.name == NSWorkspace.didActivateApplicationNotification {
            if let app = notification.userInfo?[NSWorkspace.applicationUserInfoKey] as? NSRunningApplication {
                bundleID = app.bundleIdentifier
                
                // 检查是否为系统服务相关进程
                if let id = bundleID, 
                   (id.contains("sharingd") || 
                    id.contains("continuity") || 
                    id.contains("handoff") || 
                    id.contains("pasteboard") || 
                    id == "com.apple.PBDaemonV3") {
                    
                    detectedHandoff = true
                    print("检测到Handoff相关系统服务激活: \(id)")
                }
            }
        }
        
        // 如果检测到Handoff事件
        if detectedHandoff {
            handoffDetectedTime = now
            lastHandoffBundleID = bundleID
            print("检测到Handoff相关事件，启用强制iOS检测5秒")
            
            // 标记Handoff会话活跃
            isHandoffSessionActive = true
            
            // 启用iOS检测模式
            enableForceIOSDetection(forSeconds: 5.0)
            
            // 定时检查剪贴板变化 - 使用多个间隔以增加捕获概率
            let checkIntervals = [0.5, 1.0, 2.0, 3.0]
            
            for interval in checkIntervals {
                DispatchQueue.main.asyncAfter(deadline: .now() + interval) { [weak self] in
                    guard let self = self else { return }
                    print("Handoff事件后延迟\(interval)秒检查剪贴板")
                    
                    // 检查剪贴板是否有新内容
                    let pasteboard = NSPasteboard.general
                    let changeCount = pasteboard.changeCount
                    
                    if changeCount != self.lastChangeCount {
                        print("在Handoff延迟检查中发现剪贴板变化，很可能是iOS设备内容")
                        // 立即触发检查
                        self.checkClipboard()
                    }
                }
            }
            
            // 5秒后重置Handoff会话状态
            DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) { [weak self] in
                guard let self = self else { return }
                print("重置Handoff会话状态")
                self.isHandoffSessionActive = false
            }
        }
    }
    
    // 图像处理配置结构体
    struct ImageProcessingConfig {
        var useGPU: Bool = false
        var qualityLevel: Int = 3  // 1-5，默认为中等质量
        var processingMethod: String = "standard"
    }
    
    // 获取图像处理配置
    func getImageProcessingConfig() -> ImageProcessingConfig? {
        return imageProcessingConfig
    }
    
    // 更新图像处理配置
    func updateImageProcessingConfig(_ config: ImageProcessingConfig) {
        self.imageProcessingConfig = config
        print("已更新图像处理配置：GPU加速=\(config.useGPU), 质量=\(config.qualityLevel)")
        
        // 如果开启了GPU加速，可以在这里初始化相关资源
        if config.useGPU {
            initializeGPUResources()
        }
    }
    
    // 初始化GPU资源
    private func initializeGPUResources() {
        // 实现GPU资源初始化的代码
        print("正在初始化GPU资源用于图像处理...")
        // 在实际应用中，这里可能会初始化Metal或Core Image的上下文
    }
    
    // 设置HEX颜色识别功能状态
    func setHEXColorRecognitionEnabled(_ enabled: Bool) {
        self.hexColorRecognitionEnabled = enabled
        print("已设置HEX颜色识别功能状态：\(enabled ? "启用" : "禁用")")
    }
    
    // 检测文本中的HEX颜色代码
    func detectHEXColorCodes(in text: String) -> [(String, NSColor)]? {
        // 如果功能未启用，返回nil
        if !hexColorRecognitionEnabled {
            return nil
        }
        
        // 定义HEX颜色正则表达式 (#RGB, #RRGGBB, #RRGGBBAA)
        let hexPattern = "#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})\\b"
        
        var results: [(String, NSColor)] = []
        
        do {
            let regex = try NSRegularExpression(pattern: hexPattern, options: [])
            let matches = regex.matches(in: text, options: [], range: NSRange(location: 0, length: text.utf16.count))
            
            for match in matches {
                if let range = Range(match.range, in: text) {
                    let hexCode = String(text[range])
                    if let color = NSColor(hexString: hexCode) {
                        results.append((hexCode, color))
                    }
                }
            }
        } catch {
            print("正则表达式错误: \(error)")
        }
        
        return results.isEmpty ? nil : results
    }
    
    // 处理剪贴板中的图像时应用GPU加速(修改现有方法或添加新方法)
    private func processImageWithGPUIfEnabled(_ image: NSImage) -> NSImage {
        // 如果未启用GPU加速，直接返回原图像
        if !imageProcessingConfig.useGPU {
            return image
        }
        
        print("使用GPU加速处理图像...")
        
        // 在这里实现GPU加速的图像处理逻辑
        // 例如使用Metal或Core Image处理图像
        
        // 这里是示例实现，实际应用中应替换为真正的GPU处理代码
        if let ciImage = CIImage(data: image.tiffRepresentation!) {
            let context = CIContext(options: [.useSoftwareRenderer: false])
            
            // 创建基本的图像过滤器（这里仅作演示）
            let filter = CIFilter(name: "CIColorControls")
            filter?.setValue(ciImage, forKey: kCIInputImageKey)
            filter?.setValue(1.0, forKey: kCIInputSaturationKey) // 保持原样
            
            if let outputImage = filter?.outputImage,
               let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {
                return NSImage(cgImage: cgImage, size: image.size)
            }
        }
        
        // 如果处理失败，返回原图像
        return image
    }
    
    private func extractColorsFromRichText() {
        // 检查是否启用了十六进制颜色识别
        guard UserDefaults.standard.bool(forKey: "enableHexColorRecognition") else {
            return
        }
        
        // 确保当前有剪贴板内容
        guard let currentContent = currentClipboardContent else {
            return
        }
        
        // 获取原有的颜色数据
        var hexColorData: [String: [String: String]] = currentContent.metadata["hexColors"] as? [String: [String: String]] ?? [:]
        
        // 获取剪贴板的富文本数据
        let pasteboard = NSPasteboard.general
        
        if let rtfData = pasteboard.data(forType: .rtf) ?? pasteboard.data(forType: NSPasteboard.PasteboardType("public.rtf")) {
            do {
                let attributedString = try NSAttributedString(data: rtfData,
                                                           options: [.documentType: NSAttributedString.DocumentType.rtf],
                                                           documentAttributes: nil)
                
                // 提取所有不同颜色
                var uniqueColors = Set<String>()
                var colorSamples: [String: String] = [:]
                
                attributedString.enumerateAttributes(in: NSRange(location: 0, length: attributedString.length), options: []) { attributes, range, _ in
                    if let color = attributes[.foregroundColor] as? NSColor {
                        // 转换为标准RGB色彩空间以确保一致的颜色表示
                        let rgbColor = color.usingColorSpace(.sRGB) ?? color
                        
                        // 忽略黑色和白色（常用于普通文本）
                        if (rgbColor.redComponent < 0.1 && rgbColor.greenComponent < 0.1 && rgbColor.blueComponent < 0.1) ||
                           (rgbColor.redComponent > 0.9 && rgbColor.greenComponent > 0.9 && rgbColor.blueComponent > 0.9) {
                            return
                        }
                        
                        let hexColor = rgbColor.toHexString(includeAlpha: false)
                        
                        // 添加到唯一颜色集合
                        uniqueColors.insert(hexColor)
                        
                        // 获取颜色对应的文本作为样本
                        let text = (attributedString.string as NSString).substring(with: range).trimmingCharacters(in: .whitespacesAndNewlines)
                        
                        // 如果样本不为空，存储该样本或更新为更好的样本（非空或更长的样本）
                        if !text.isEmpty {
                            if let existingSample = colorSamples[hexColor] {
                                // 保留更长的样本文本
                                if text.count > existingSample.count {
                                    colorSamples[hexColor] = text
                                }
                            } else {
                                colorSamples[hexColor] = text
                            }
                        }
                    }
                }
                
                // 如果有颜色，保存到metadata中
                if !uniqueColors.isEmpty {
                    for hexColor in uniqueColors {
                        let sampleText = colorSamples[hexColor] ?? ""
                        
                        // 为每种颜色创建或更新数据
                        if hexColorData[hexColor] == nil {
                            hexColorData[hexColor] = [
                                "sampleText": sampleText,
                                "source": "richText"
                            ]
                        } else if hexColorData[hexColor]?["sampleText"]?.isEmpty ?? true, !sampleText.isEmpty {
                            // 更新样本文本（如果之前是空的）
                            hexColorData[hexColor]?["sampleText"] = sampleText
                        }
                    }
                    
                    // 更新metadata
                    currentContent.metadata["hexColors"] = hexColorData
                    
                    // 打印结果
                    print("从富文本中提取了\(uniqueColors.count)个颜色:")
                    for hexColor in uniqueColors {
                        print("- 颜色: \(hexColor), 样本: \"\(colorSamples[hexColor] ?? "")\"")
                    }
                }
            } catch {
                print("解析富文本数据失败: \(error)")
            }
        }
    }
} 